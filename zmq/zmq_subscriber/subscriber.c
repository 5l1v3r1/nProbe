#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <sys/time.h>
#include <time.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <zmq.h>

#define TOPIC "flow"

#define MSG_VERSION 0

struct zmq_msg_hdr {
  char url[32];
  u_int32_t version;
  u_int32_t size;
};

void help() {
  printf("subscriber -i <iface> [-v] [-t <flow|event|both>][-f <IP:port>]\n\n\n"
	 "Example: subscriber -i tcp://127.0.0.1:5556 -f 192.168.1.1:1234\n\n"
	 "Subscribe to ZMQ events generated by tcp://127.0.0.1:5556 and forward them\n"
	 "via TCP to 192.168.1.1:1234\n"
	 );
  
  exit(0);
}

int main (int argc, char *argv []) {
  void *context = zmq_ctx_new();
  void *subscriber = zmq_socket(context, ZMQ_SUB);
  char *payload, c;
  int payload_len, verbose = 0;
  int rc, size;
  struct zmq_msg_hdr h;
  char *iface = NULL; // "tcp://127.0.0.1:5556";
  char *topic = TOPIC;
  char *forward_host = NULL;
  int tcp_socket = -1;
  struct sockaddr_in servaddr;
  
  while((c = getopt(argc, argv, "i:t:hf:v")) != -1) {
    switch(c) {
    case 'f':
      forward_host = optarg;
      break;
    case 'i':
      iface = optarg;
      break;
    case 't':
      topic = optarg;
      break;
    case 'v':
      verbose = 1;
      break;
    default:
      help();
    }
  }

  if((iface == NULL) || (topic == NULL))
    help();

 redo:
  if(forward_host) {
    char buf[256], *host, *port;
    struct hostent *server;

    snprintf(buf, sizeof(buf), "%s", forward_host);

    host = strtok(buf, ":");
    if(!host) help();

    port = strtok(NULL, ":");
    if(!port) help();

    if(!(server = gethostbyname(host))) {
      printf("Unknown host %s\n", host);
      help();
    }

    tcp_socket = socket(AF_INET, SOCK_STREAM, 0);

    bzero(&servaddr, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = (*(struct in_addr *)server->h_addr_list[0]).s_addr;
    servaddr.sin_port=htons(atoi(port));

    if((rc = connect(tcp_socket, (struct sockaddr *)&servaddr, sizeof(servaddr))) != 0) {
      printf("Unable to connect to %s:%s [%s/%u]\n", host, port, strerror(errno), errno);
      help();
    } else
      printf("Connected to %s:%s\n", host, port);
  }

  rc = zmq_connect(subscriber, iface);

  if (rc != 0)
    return -1;

  if(strcmp(topic, "both") == 0) {
    char *t;

    t = "event"; rc = zmq_setsockopt(subscriber, ZMQ_SUBSCRIBE, t, strlen(t));
    t = "flow"; rc = zmq_setsockopt(subscriber, ZMQ_SUBSCRIBE, t, strlen(t));
  } else
    rc = zmq_setsockopt(subscriber, ZMQ_SUBSCRIBE, topic, strlen(topic));

  if (rc != 0)
    return -1;

  printf("Listening for %s on %s\n", topic, iface);

  while (1) {
    char theDate[32];
    time_t theTime;
    struct zmq_msg_hdr msg_hdr;

    size = zmq_recv(subscriber, &h, sizeof(h), 0); 

    if (size != sizeof(h) || h.version != MSG_VERSION) {
      printf("Unsupported publisher version\n");
      return -1;
    }

    payload_len = h.size + 2;
    payload = malloc(payload_len);

    size = zmq_recv(subscriber, payload, payload_len, 0); 

    if(tcp_socket != -1) {
      payload[h.size] = '\n';
      payload[h.size+1] = '\0';
      rc = write(tcp_socket, payload, (int)(h.size+1));

      if(rc < 0) {
	printf("Send error %d [%s/%u]\n", tcp_socket, strerror(errno), errno);
	zmq_close(subscriber);
	zmq_ctx_destroy(context);
	close(tcp_socket);
	sleep(1);
	goto redo;
	break;
      }
      
      printf("%s", payload);
    } 

    if(verbose) {
      time_t theTime = time(NULL);

      payload[h.size] = '\0';
      
      strftime(theDate, 32, "%d/%b/%Y %H:%M:%S", localtime(&theTime));
      printf("[%s] %s\n", theDate, payload);
    }

    free(payload);
  }

  zmq_close(subscriber);
  zmq_ctx_destroy(context);

  return 0;
}

